# 基准测试

## 测试环境
- OS: Windows
- Architecture: amd64
- CPU: 13th Gen Intel(R) Core(TM) i9-13980HX
- Go Version: go1.21+

## 性能测试结果

### 基础操作性能

| 操作类型 | 执行次数/秒 | 延迟(ns/op) | 内存分配(B/op) | 内存分配次数(allocs/op) |
|----------|-------------|-------------|----------------|----------------------|
| Set      | 46,102      | 24,828      | 406           | 11                  |
| Get      | 47,534      | 24,391      | 384           | 12                  |
| Pipeline | 5,358       | 314,300     | 53,433        | 1,021               |

### 性能分析

#### 单个操作 (Get/Set)
- 平均延迟低于 25 微秒
- 每秒可处理约 40,000+ 请求
- 内存使用效率高（每操作约 400 字节）
- 内存分配次数少（每操作 11-12 次）

#### Pipeline 批量操作
- 每批次包含 100 个操作
- 实际单个操作性能：
  - 延迟：3.143 微秒/操作 (314.3 微秒/100操作)
  - 吞吐量：318,000 QPS (3,180 批次/秒 × 100 操作/批次)
  - 内存效率：534 字节/操作 (53.4KB/100操作)

### 性能对比

| 指标     | 单个操作    | Pipeline 批量操作 | 性能提升 |
|----------|------------|------------------|----------|
| 延迟     | 24.8 微秒  | 3.143 微秒       | 8倍      |
| QPS      | 40,000     | 318,000         | 8倍      |
| 内存/操作 | ~400 字节  | ~534 字节        | -33%     |

### 结论
1. 单个操作性能表现优秀：
   - 低延迟
   - 高效的内存使用
   - 稳定的操作表现

2. Pipeline 批量操作显著提升性能：
   - 延迟减少约 8 倍
   - 吞吐量提升约 8 倍
   - 轻微增加的内存开销换取了显著的性能提升

3. 整体性能评估：
   - 当前实现性能表现优秀
   - 满足大多数生产环境需求
   - 内存使用与性能的平衡良好

### 建议
- 对于批量操作场景，优先使用 Pipeline 模式
- 对于单个操作场景，直接使用 Get/Set 操作即可
- 当前实现已经达到很好的性能水平，无需特别优化

